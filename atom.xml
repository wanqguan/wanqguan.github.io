<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wanqguan.github.io</id>
    <title>忘荃编程</title>
    <updated>2021-03-28T08:53:17.229Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wanqguan.github.io"/>
    <link rel="self" href="https://wanqguan.github.io/atom.xml"/>
    <subtitle>艺术×算法×启蒙：
Coding的最小闭环，
人类智慧的精粹。</subtitle>
    <logo>https://wanqguan.github.io/images/avatar.png</logo>
    <icon>https://wanqguan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 忘荃编程</rights>
    <entry>
        <title type="html"><![CDATA[蓝桥杯 基础题]]></title>
        <id>https://wanqguan.github.io/post/lan-qiao-bei-ji-chu-ti/</id>
        <link href="https://wanqguan.github.io/post/lan-qiao-bei-ji-chu-ti/">
        </link>
        <updated>2021-03-28T08:24:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="prev-65-单词分析">PREV-65 单词分析</h2>
<p>问题描述<br>
小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。</p>
<p>现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数。</p>
<p>输入格式<br>
输入一行包含一个单词，单词只由小写英文字母组成。</p>
<p>输出格式<br>
输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪个。如果有多个字母出现的次数相等，输出字典序最小的那个。</p>
<p>第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。<br>
<strong>代码</strong>：</p>
<pre><code class="language-python">from collections import defaultdict

test = input()

ans = defaultdict(int)

for t in test:
    ans[t] += 1

maxy = max(ans.values())
keys = list(ans.keys())
for k in sorted(keys):
    if ans[k] == maxy:
        print(k)
        print(maxy)
        break
</code></pre>
<h2 id="成绩分析">成绩分析</h2>
<p>问题描述<br>
小蓝给学生们组织了一场考试，卷面总分为  分，每个学生的得分都是一个  到  的整数。<br>
请计算这次考试的最高分、最低分和平均分。</p>
<p>输入格式<br>
输入的第一行包含一个整数 ，表示考试人数。<br>
接下来  行，每行包含一个  至  的整数，表示一个学生的得分。</p>
<p>输出格式<br>
输出三行。<br>
第一行包含一个整数，表示最高分。<br>
第二行包含一个整数，表示最低分。<br>
第三行包含一个实数，四舍五入保留正好两位小数，表示平均分。</p>
<p><strong>代码</strong>：</p>
<pre><code class="language-python">n = int(input())

data = [0] * n
for i in range(n):
    data[i] = int(input())

# data = [1,2,3,4,5]

print(max(data))
print(min(data))
print(&quot;{:.2f}&quot;.format(sum(data) / len(data)))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[蓝桥杯 PREV-67 字串排序 70%]]></title>
        <id>https://wanqguan.github.io/post/lan-qiao-bei/</id>
        <link href="https://wanqguan.github.io/post/lan-qiao-bei/">
        </link>
        <updated>2021-03-26T03:27:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p><a href="http://lx.lanqiao.cn/problem.page?gpid=T803">原题链接</a></p>
<p>资源限制<br>
时间限制：1.0s   内存限制：256.0MB<br>
问题描述<br>
小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。<br>
在冒泡排序中，每次只能交换相邻的两个元素。<br>
小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符，则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。<br>
例如，对于字符串 <code>lan</code> 排序，只需要 <code>1</code> 次交换。对于字符串 <code>qiao</code> 排序，总共需要 <code>4</code> 次交换。</p>
<p>小蓝的幸运数字是 V，他想找到一个只包含小写英文字母的字符串，对这个串中的字符进行冒泡排序，正好需要 V 次交换。请帮助小蓝找一个这样的字符串。如果可能找到多个，请告诉小蓝最短的那个。如果最短的仍然有多个，请告诉小蓝字典序最小的那个。请注意字符串中可以包含相同的字符。</p>
<p>输入格式<br>
输入一行包含一个整数 ，为小蓝的幸运数字 V。</p>
<p>输出格式<br>
输出一个字符串，为所求的答案。</p>
<pre><code>样例输入
4
样例输出
bbaa

样例输入
100
样例输出
jihgfeeddccbbaa
</code></pre>
<h2 id="分析题目">分析题目</h2>
<p>这个题本身还是有难度的。对于已知的一个乱序的序列，只能用相邻交换时候，求最小交换次数的话，应该是一个很典型的常见算法问题。但是这个题使用了逆向思维，转而问满足某一个最小交换次数的乱序序列。顿时就有点让人无从下手，还好题目中还出现了两个关键提示：<br>
提示1： 如果对一个字符串中的字符排序，只允许交换相邻的两个字符，则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。<br>
提示2： 这个提示隐藏在样例输出中，通过观察样例输出bbaa和jihgfeeddccbbaa。所以从这点上就可以初步猜测，最小排序的答案往往是右边是每个字母二次重复的序列，而左边则是没有重复的序列，且整个构成的字母从右到左是abcdef... 。（我们暂时称这种序列为“理想序列”，因为我们假设正确答案一定是理想序列中的一个）</p>
<p>从两个提示下手，经过分析，我最后发现了这样的规律（假设由前面n个单，后面m个双数构成）：<br>
一个乱序序列的最小交换次数通常有三部分组成，以<code>jihgfeeddccbbaa</code>为例子（n=5, m=5）。<br>
-1 第一部分是左边无重复部分 <code>jihgf</code> 的内部排序次数 <code>n * (n-1) / 2</code>；<br>
-2 第二部分是右边2次重复部分<code>eeddccbbaa</code> 的内部排序次数<code>m * (m-1) * 2</code>；<br>
-3 第三部分是右边2次重复部分<code>eeddccbbaa</code> 因为左边无重复部分而多使用的排序次数<code>m * n * 2</code>。<br>
这样，我们就得到了计算理想序列的交换数的函数：</p>
<pre><code class="language-python">def cacl_mn_cishu(m, n):
    &quot;前面n个单，后面m个双数&quot;
    shuangs = m * (m-1) * 2  # 偶数
    if shuangs &lt;0: shuangs=0
    shuangs_up = m * n * 2  # 偶数
    dans = n * (n-1) / 2  # 奇数
    if dans &lt;0: dans=0
    # print(shuangs, shuangs_up, dans)
    return shuangs + shuangs_up + dans
</code></pre>
<p>发现这个函数后，我们发现每个理想序列都可以用（m,n）这样的元组来表示，而且各个理想序列还通过这样的方式相互联系了起来。（有兴趣的话，可以自己推到一下m,n到 m,n+1 或者 m+1, n的递推公式）。</p>
<p>最后得到一个初步的解决方案：</p>
<h2 id="我的代码">我的代码</h2>
<pre><code class="language-python"># %%
from functools import wraps

alphabs = 'abcdefghijklmnopqrstuvwxyz'

def memo(func):
    &quot;记忆体化的通用函数”
    cache = {}                                  # Stored subproblem solutions
    @wraps(func)                                # Make wrap look like func
    def wrap(*args):                            # The memoized wrapper
        if args not in cache:                   # Not already computed?
            cache[args] = func(*args)           # Compute &amp; cache the solution
        return cache[args]                      # Return the cached solution
    return wrap                                 # Return the wrapper

def cacl_mn_cishu(m, n):
    &quot;前面n个单，后面m个双数&quot;
    shuangs = m * (m-1) * 2  # 偶数
    if shuangs &lt;0: shuangs=0
    shuangs_up = m * n * 2  # 偶数
    dans = n * (n-1) / 2  # 奇数
    if dans &lt;0: dans=0
    # print(shuangs, shuangs_up, dans)

    return shuangs + shuangs_up + dans

# # Test
# print(cacl_mn_cishu(2, 0)  )
# print(cacl_mn_cishu(1, 2)  )
# print(cacl_mn_cishu(5, 5)  )

def solve_tar(tar):
    @memo
    def my_solve(m, n, tar):
        # print(m, n)
        if cacl_mn_cishu(m, n) == tar:
            return m, n
        elif cacl_mn_cishu(m, n) &lt; tar:
            m1n = my_solve(m+1, n, tar)
            if m1n: return m1n
            mn1 = my_solve(m, n+1, tar)
            if mn1: return mn1

    m, n = my_solve(0, 0, tar)
    return m, n

def shengcheng(m, n):
    ans = []
    for i in range(m):
        ans += alphabs[i]
        ans += alphabs[i]
    for i in range(m, m+n):
        ans += alphabs[i]
    return ''.join(reversed(ans))

# print(shengcheng(5, 5))

tar = int(input())
m, n = solve_tar(tar)
# print(m, n)
ans = shengcheng(m, n)
print(ans)



# %%

</code></pre>
<h2 id="遗留问题">遗留问题</h2>
<p>1 整个解法是猜想性的，其正确性并没有被严密的证明<br>
2 当V过大的时候，字母表可能不够用，这个时候答案会出现错误，这可能是最后该代码没有拿到100%通过的原因。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python练习：24点游戏]]></title>
        <id>https://wanqguan.github.io/post/python-lian-xi-24-dian-you-xi/</id>
        <link href="https://wanqguan.github.io/post/python-lian-xi-24-dian-you-xi/">
        </link>
        <updated>2021-03-26T02:27:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="编程目标">编程目标：</h2>
<p>输入一串数字，如 3,5,7,9， 然后再输入一个目标数字，如5，然后求一个在3,5,7,9四个数字之间增加四则运算，括号，以及 '求根', '平方', '立方', '阶乘' 四种操作的一个方案，最终让整个四个数字的运算结果等于目标数字。</p>
<h2 id="编程效果">编程效果：</h2>
<p>输入一串数字，如 3,5,7,9，目标数字依次是从1到10。</p>
<pre><code>
import math...
********** Solve 1 **********
Step 4 :  10 - 11 = 1
  然后整体操作：  平方
Step 3 :  1 + 9 = 10
Step 2 :  8 - 7 = 1
Step 1 :  3 + 5 = 8

********** Solve 2 **********
Step 4 :  9 - 11 = 2
  然后整个取相反数
Step 3 :  1 * 9 = 9
Step 2 :  8 - 7 = 1
Step 1 :  3 + 5 = 8

********** Solve 3 **********
Step 4 :  -8 + 11 = 3
Step 3 :  1 - 9 = -8
Step 2 :  8 - 7 = 1
Step 1 :  3 + 5 = 8

********** Solve 4 **********
Step 4 :  5.0 + 11 = 4.0
  然后整体操作：  求根
Step 3 :  225 / 9 = 5.0
  然后整体操作：  求根
Step 2 :  8 + 7 = 225
  然后整体操作：  平方
Step 1 :  3 + 5 = 8

********** Solve 5 **********
Step 4 :  6 - 11 = 5
  然后整个取相反数
Step 3 :  15 - 9 = 6
Step 2 :  8 + 7 = 15
Step 1 :  3 + 5 = 8

********** Solve 6 **********
Step 4 :  25.0 + 11 = 6.0
  然后整体操作：  求根
Step 3 :  225 / 9 = 25.0
Step 2 :  8 + 7 = 225
  然后整体操作：  平方
Step 1 :  3 + 5 = 8

********** Solve 7 **********
Step 4 :  15 + -8 = 7
Step 3 :  9 - 11 = -8
  然后整体操作：  立方
Step 2 :  8 + 7 = 15
Step 1 :  3 + 5 = 8

********** Solve 8 **********
Step 4 :  56 - -8 = 8.0
  然后整体操作：  求根
Step 3 :  9 - 11 = -8
  然后整体操作：  立方
Step 2 :  8 * 7 = 56
Step 1 :  3 + 5 = 8

********** Solve 9 **********
Step 4 :  -8 + 11 = 9
  然后整体操作：  平方
Step 3 :  1 - 9 = -8
Step 2 :  8 - 7 = 1
Step 1 :  3 + 5 = 8

********** Solve 10 **********
Step 4 :  1 + 99 = 10.0
  然后整体操作：  求根
Step 3 :  9 * 11 = 99
Step 2 :  8 - 7 = 1
Step 1 :  3 + 5 = 8
</code></pre>
<h2 id="分析">分析</h2>
<p>在力扣上有一个类似的题目：<a href="https://leetcode-cn.com/problems/24-game/solution/24-dian-you-xi-by-leetcode-solution/">力扣 24 点游戏 官方题解</a>。其中的主要思路就是通过不断地将2个材料数字合并成一个数字，最终达到对所有方案的遍历，并从中尝试找到符合要求的方案。<br>
本质上，这是一种对树结构的遍历。<br>
而我们这里的场景和题目还有以下不同：<br>
-1 必须在相邻的数字之间才能进行运算并合并成一个数字<br>
-2 要求输出得到的答案的中间计算过程，而不仅仅是输出有或者没有答案<br>
-3 还可以选择对任意中间结果采取 '求根', '平方', '立方', '阶乘' 四种操作的某个操作<br>
根据这些差别，我经过改进最终得到了以下代码：</p>
<h2 id="代码">代码</h2>
<pre><code class="language-python">import math

func0 = lambda x: x
func1 = lambda x: math.sqrt(x)
func2 = lambda x: x**2
func3 = lambda x: x**3
func4 = lambda x: math.factorial(x)
total_more_func = [func0, func1, func2, func3, func4]
total_more_name = ['无', '求根', '平方', '立方', '阶乘']

# 下面这个函数计算任意左边是nums，右边是target的24点游戏的目标数字
def judgePointGame(nums, target):
    TARGET = target
    EPSILON = 1e-12
    ADD, MULTIPLY, SUBTRACT, DIVIDE = 0, 1, 2, 3
    cacl_dict = ['+', '*', '-', '/']

    
    def solve(nums, step):
        if not nums:
            return False
        if len(nums) == 1:
            return abs(nums[0] - TARGET) &lt; EPSILON

        for i in range(0, len(nums) - 1):
            x = nums[i]
            y = nums[i+1]
            for k in range(4):  # 为 x？y 遍历尝试4种计算，并将结果保存进newNums
                for getfu in (0, 1):
                    for total_more in range(4):
                        newNums = nums[:i]

                        if k == ADD:
                            tmp = x + y
                        elif k == MULTIPLY:
                            tmp = x * y
                        elif k == SUBTRACT:
                            tmp = x - y
                        elif k == DIVIDE:
                            if abs(y) &lt; EPSILON:
                                continue
                            tmp = x / y
                        
                        if getfu == 1:
                            tmp = -tmp

                        func = total_more_func[total_more]
                        try:
                            tmp = func(tmp)
                        except ValueError:
                            continue

                        newNums.append(tmp)

                        newNums.extend(nums[i+2:])
                        if solve(newNums, step+1):
                            print(&quot;Step&quot;, step, ': ', x, cacl_dict[k], y, '=', tmp)
                            if getfu == 1:
                                print(&quot;  然后整个取相反数&quot;)
                            if total_more &gt;= 1:
                                print(&quot;  然后整体操作： &quot;, total_more_name[total_more])
                            return True

        
        
        return False

    return solve(nums, 1)


# 依次计算1-10的目标数字，材料数字是 [3,5,7,9]的24点游戏方案
for i in range(1, 11):
    print('*'*10, &quot;Solve&quot;, i, '*'*10)
    judgePointGame([3,5,7,9], i)
    print()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[写作平台测试（同步时关科学上网）]]></title>
        <id>https://wanqguan.github.io/post/zhi-hu-jing-hua-da-xue-sheng-huo-zhong-de-bo-yi-jue-ce-yu-chao-yue/</id>
        <link href="https://wanqguan.github.io/post/zhi-hu-jing-hua-da-xue-sheng-huo-zhong-de-bo-yi-jue-ce-yu-chao-yue/">
        </link>
        <updated>2021-03-24T13:44:45.000Z</updated>
        <content type="html"><![CDATA[<p>先开个头~</p>
<p>代码测试：</p>
<pre><code class="language-python">def get(a):
    a = 2  # 代码测试
    return a

print(get(a))
</code></pre>
<p>测试链接：<br>
<a href="https://wanqguan.github.io/post/ge-ren-sui-xiang/">我的第一篇文章</a></p>
<p>格式测试：</p>
<h1 id="一级标题">一级标题</h1>
<h2 id="二级标题">二级标题</h2>
<h3 id="三级标题">三级标题</h3>
<p><strong>加粗</strong><br>
普通</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[个人写作随想：从知乎到个人博客]]></title>
        <id>https://wanqguan.github.io/post/ge-ren-sui-xiang/</id>
        <link href="https://wanqguan.github.io/post/ge-ren-sui-xiang/">
        </link>
        <updated>2021-03-24T13:16:09.000Z</updated>
        <content type="html"><![CDATA[<p>之前一直在知乎写技术或者生活分享类的文章，用了一年之后，发现有些东西直接发在知乎上并不方便，所以经过反复的心理斗争最后给自己又整了个简单的个人小博客。<br>
<img src="https://wanqguan.github.io/post-images/1616591949321.png" alt="我目前的知乎的创作数据" loading="lazy"></p>
<h3 id="先稍微总结下对知乎不满意的地方吧">先稍微总结下对知乎不满意的地方吧：</h3>
<ul>
<li>1 草稿机制不太好用，所以我个人习惯写一个不成熟的版本然后直接发布，然后这个文章就进入评价机制，导致被评价得不够高。另外一方面，这些曾经热血上头或者水平不够写出来的文章侥幸获得了几个赞，以后想起来又想删又怕浪费了，总之就是各种迭代会很麻烦。</li>
<li>2 没有好用的导航和目录形式，导致很难在直观上把文章之间和文章内部的格式给统一起来</li>
<li>3 流量变现模式不成熟，对技术类创作者的奖励过少，让我感觉在知乎上即使写了很多东西也不被重视，看不到收获的希望。我最希望知乎出现的功能是，知乎能把知乎live形式给补充得更完善，这样方便做成一些技术类视频课放上去卖。但是知乎新出了很多功能，唯独知乎live还是老样子。</li>
</ul>
<p>主要就是这三点是核心的原因，当然在线编辑器不好用，杠精太多，推荐机制和抱团行为等还有很多琐碎的缺点。最后不得不说知乎也有优点，比如说有所谓的版权保护，还有粉丝和流量机制，最近还在一直间歇不断地组织各种活动，但是这些东西现在都不太能吸引我了。</p>
<h3 id="未来的规划">未来的规划</h3>
<ul>
<li>1 未来准备把付费内容和免费内容分开。免费内容就放到个人的博客上，付费内容就另外放在其他地方。这样清者升，浊者降，免费内容结构更加清晰了，付费内容的方向和价格也更加清晰了，最后的整体效果相信会让老朋友们耳目一新的。</li>
<li>2 作为知乎上内容发布的补充，这个博客的内容将主要吧以前知乎上零散发布的技术类内容重新梳理成最完整的形式，同时在其发布后一直保持更新迭代，修改错误或者补充内容。</li>
</ul>
]]></content>
    </entry>
</feed>